<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Fur Rendering</title>

    <!-- Bootstrap core CSS -->
    <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom styles for this template -->
    <link href="css/modern-business.css" rel="stylesheet">

    <!-- code highlighting -->
    <link rel="stylesheet" href="styles/github-gist.css">
    <script src="js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

</head>

<body>

<nav class="navbar fixed-top navbar-expand-lg navbar-dark bg-dark fixed-top">
    <div class="container">
        <a class="navbar-brand" href="index.html">Cédric Van Huffelen</a>
        <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
                data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
                aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarResponsive">
            <ul class="navbar-nav ml-auto">
                <li class="nav-item">
                    <a class="nav-link" href="about.html">About</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="portfolio-1-col.html">Portfolio</a>
                </li>
                <li class="nav-item">
                    <a class="nav-link" href="resume.html">Resume</a>
                </li>
            </ul>
        </div>
    </div>
</nav>

<!-- Page Content -->
<div class="container">

    <!-- Page Heading/Breadcrumbs -->
    <h1 class="mt-4 mb-3">Fur rendering using fins and shells
    </h1>

    <ol class="breadcrumb">
        <li class="breadcrumb-item">
            <a href="index.html">Home</a>
        </li>
        <li class="breadcrumb-item">
            <a href="portfolio-1-col.html">Portfolio</a>
        </li>
        <li class="breadcrumb-item active">Fur rendering using fins and shells</li>
    </ol>

    <p>
        Fur is typically rendered using 2 approaches. Rendering all the individual hairs as geometry, or by volume
        rendering.
        With this method you render with multiple passes which rely heavily on geometry shaders; The first pass renders
        the base mesh, then you render the fins.
        Those are quads extruded from the silhouettes of the mesh and rendered with alpha blending.
        The last pass renders each shell one by one from the inside out. Shells are the mesh extruded by the normal with
        a proportional index.
    </p>

    <div id="carouselExampleIndicators" class="carousel slide" data-ride="carousel">
        <ol class="carousel-indicators">
            <li data-target="#carouselExampleIndicators" data-slide-to="0" class="active"></li>
            <li data-target="#carouselExampleIndicators" data-slide-to="1"></li>
            <li data-target="#carouselExampleIndicators" data-slide-to="2"></li>
            <li data-target="#carouselExampleIndicators" data-slide-to="3"></li>
        </ol>
        <div class="carousel-inner portfolio-slideshow" role="listbox">
            <!-- Slide One - Set the background image for this slide in the line below -->
            <div class="carousel-item active"
                 style="background-image: url('Images/Projects/FurRendering/SnowFur_Demo700x400.png')">
            </div>
            <!-- Slide Two - Set the background image for this slide in the line below -->
            <div class="carousel-item"
                 style="background-image: url('Images/Projects/FurRendering/PantherFur_Demo700x400.png')">
            </div>
            <!-- Slide Three - Set the background image for this slide in the line below -->
            <div class="carousel-item"
                 style="background-image: url('Images/Projects/FurRendering/TigerFur_Demo700x400.png')">
            </div>
            <!-- Slide Three - Set the background image for this slide in the line below -->
            <div class="carousel-item"
                 style="background-image: url('Images/Projects/FurRendering/BearFur_Demo700x400.png')">
            </div>
        </div>
        <a class="carousel-control-prev" href="#carouselExampleIndicators" role="button" data-slide="prev">
            <span class="carousel-control-prev-icon" aria-hidden="true"></span>
            <span class="sr-only">Previous</span>
        </a>
        <a class="carousel-control-next" href="#carouselExampleIndicators" role="button" data-slide="next">
            <span class="carousel-control-next-icon" aria-hidden="true"></span>
            <span class="sr-only">Next</span>
        </a>
    </div>

    <hr>

    <h3>The first pass - the base object</h3>
    <p>
        The first pass is a very simple draw of the model itself using a normal vertex and fragment shader.
        While we calculate the lighting in the fragment shader the normal way (simple lambert diffuse lighting), we
        darken the result a little bit to fake the hairs casting shadows on the model itself as it would in real
        life

    <div>
        <section>
            <pre>
                <code class="cpp codeBlock">
// Vertex shader input
struct VS_Input {
   float4 vertex : POSITION;
   float3 normal : NORMAL;
   float2 uv     : TEXCOORD0;
};

// Vertex shader output | Fragment shader input
struct VS_Output {
   float4 position : SV_POSITION;
   float3 wNormal  : NORMAL; // Normal vector in World Space
   float2 uv       : TEXCOORD0;
   float3 ambient  : TEXCOORD1; // Used to save scene ambient lighting
};

VS_Output vert(VS_Input i)
{
   VS_Output o;
   o.position = UnityObjectToClipPos(i.vertex);

   // Calculate world normal
   o.wNormal = UnityObjectToWorldNormal(i.normal);

   // Transform the UV's so it works with the texture scale and offset
   o.uv = TRANSFORM_TEX(input.uv, _MainTex);

   // Calculate ambient scene lighting
   o.ambient = ShadeSH9(half4(o.wNormal, 1));
}

half4 fragment(VS_Output i) : SV_Target
{
   // Calculate albedo
   half4 color = tex2D(_MainTex, i.uv) * _Color;

   // Calculate lighting and add ambient light
   half3 NdotL = saturate(dot(i.wNormal, _WorldSpaceLightPos0.xyz)) * _LightColor0.rgb;
   NdotL += i.ambient;

   // Apply lighting and darken the color with 20%
   color.rgb *= NdotL;
   color.rgb *= 0.8h;

   return color;
}
                </code>
            </pre>
        </section>
    </div>
    </p>

    <hr>


    <h3>The second pass - the fins</h3>
    <p>
        The fins are rendered to preserve the illusion of fur along the silhouette edges. The fins are generated in the
        <b>geometry shader</b>. In this pass, quads will be generated perpendicular to the surface of the base object.
        Instead of using a vertex shader like in the previous pass, we immediately send the input to the geometry
        shader.
    </p>
    <p>
        For the input of our geometry shader we choose <b>line</b> as our <b>Primitive Type</b>. Each line consists out
        of 2 points (vertices), which gives us enough information to generate the quad. Since we have our edge, we have
        to determine if it lays on the silhouette and has to be extruded or not. If the dot product of the <b>edge
        normal</b> and the <b>eye vector</b> is close to <b>0</b>, then the edge lays on the silhouette.
        This <b>edge normal</b> can be calculated by simply averaging the 2 normals of the vertices. After we have found
        our edge we still need to generate the quad. Because we already have 2 of the 4 points we only have to calculate
        the last 2 by pushing each point outwards in the direction of its normal vector.
    <div class="alert alert-danger" role="alert">
        It is important that you push the points using their own vertex normal. if you would use the edge vector then
        you can get broken silhouettes on edges that are supposed to be smooth!
    </div>

    <div>
        <section>
                <pre>
                    <code class="cpp codeBlock">
struct VS_Data // Geometry shader input | this value is immediately send to the geometry shader
{
    float4 vertex : POSITION;
    float3 normal : NORMAL;
    float2 uv     : TEXCOORD0;
};

struct GS_Data
{
    float4 vertex  : SV_POSITION;
    float3 wNormal : NORMAL;
    float2 finUV   : TEXCOORD0; // the uv's for the fin texture
    float2 uv      : TEXCOORD1; // the original uv's to color the fins based on the albedo texture
    float3 ambient : TEXCOORD2; // Used to calculate ambient lighting
};

VS_Data vert( VS_Data input)
{
    return input;
}

// function to create and append a vertex to the Triangle Stream
void CreateVertex(inout TriangleStream triStream,
   float3 pos, float3 normal, float2 finUV, float2 uv)
{
    GS_Data data;
    data.vertex = UnityObjectToClipPos(float4(pos, 1.0));
    data.wNormal = UnityObjectToWorldNormal(normal);
    data.finUV = finUV;
    data.uv = TRANSFORM_TEX(uv, _MainTex);
    data.ambient = ShadeSH9(half4(data.wNormal, 1));

    triStrean.Append(data);
}

[maxvertexcount(4)] //  maximum 4 vertices since we only need to generate a quad
void geom(line VS_Data input[2], inout TriangleStream triStream)
{
    // edge normal
    float3 edgeNormal = normalize((input[0].normal + input[2].normal) / 2);

    // calculate view direction using the center of the edge
    float3 midPoint = (input[0].vertex + input[1].vertex) /2;
    float3 viewDir = ObjSpaceViewDir(float4(midPoint, 1.0));

    // See if the edge lays on the silhouette by checking the dot product and a threshold
    float NdotV = dot(edgeNormal, viewDir);
    if( NdotV > - _FinTreshold && NdotV < _FinTreshold)
    {
        // UV's for the fin texture
        float2 uv  = float2(0.0f, 1.0f);
        float2 uv1 = float2(1.0f, 1.0f);
        float2 uv2 = float2(0.0f, 0.1f);
        float2 uv3 = float2(1.0f, 0.1f);

      #if UNITY_UV_STARTS_AT_TOP
        uv.y  = 1 - uv.y;
        uv1.y = 1 - uv1.t;
        uv2.y = 1 - uv2.y;
        uv3.y = 1 - uv3.y;
      #endif

        // Create the vertices of the quad
        CreateVertex(triStream, input[0].vertex, edgeNormal, uv , input[0].uv);
        CreateVertex(triStream, input[1].vertex, edgeNormal, uv1, input[1].uv);

        // create the upper vertices by extruding along the VERTEX normal
        CreateVertex(triStream, input[0].vertex + input[0].normal * (_FurLength * _FinLength), edgeNormal, uv2, input[0].uv);
        CreateVertex(triStream, input[1].vertex + input[1].normal * (_FurLength * _FinLength), edgeNormal, uv3, input[1].uv);
    }
}

half4 fragment(GS_Data input) : SV_Target
{
    // Diffuse color
    half4 color = tex2D(_MainTex, input.uv ) * _Color;

    // Fin texture
    float finOpacity = tex2D(_FinOpacityTex, input.finUV).r;
    color.a *= finOpacity;

    // Lighting
    float3 NdotL = saturate(dot(input.wNormal, _WorldSpaceLightPos0.xyz)) * _LightColor0.rgb;
    NdotL += i.ambient;
    color.rgb *= NdotL;

    return color;
}
                    </code>
                </pre>
        </section>
    </div>

    </p>
    </p>

    <hr>

    <h3>The third pass - the shells</h3>
    <p>
        The last step in rendering our fur is the shells. These shells are rendered from the inside out by generating
        the mesh <b>n</b> times. Every time the mesh is generated, we extrude it along its normal by an amount
        proportional to
        the index of the shell. Because of this, we make use of a second geometry shader with triangles.
    </p>
    <p>
        To generate the mesh multiple times we use a for loop to iterate <b>n</b> amount of times. Each iteration, we
        use the
        input vertices as a base and then offset them using the current layer index. This makes that every time we
        generate a new layer, it is extruded a little bit further than the previous layer. to calculate this offset we
        take the length of the fur and divide it by the number of layers we want to generate.
    </p>

    <p>
        In the pixel shader, we use the same lighting calculation as in the first 2 passes. However, instead of getting
        the ambient scene color in the vertex shader, we have to call it in the pixel shader. This is because we won't
        be able to save it in the output of the geometry shader. In DirectX11 we can only save a maximum of 1024 scalar
        components shared over all the generated vertices. To calculate how many scalar components we use in our
        geometry shader, we take the maximum vertex count and multiply them with each scalar component in our output
        struct.
    <div class="alert alert-warning" role="alert">
        Remember that a float2 counts as 2 scalars, a float3 as 3 and so on.
    </div>
    In this case, our maximum vertex count is 90 (30 triangles * 3 vertices) and we have 10 scalar components in the
    output struct. (1 float4, 1 float3, 1 float2 and 1 int => 4 + 3 + 2 + 1 = 10). In total, this gives 900 scalar
    components. if we would save the ambient value ( another float3) in the struct, then we would reach 11770 scalars and
    surpass the 1024 limit.

    <div>
        <section>
                <pre>
                    <code class="cpp codeBlock">
struct VS_Data
{
    float4 vertex  : POSITION;
    float3 normal  : NORMAL;
    float2 uv      : TEXCOORD0;
};

struct GS_Data
{
    float4 vertex  : SV_POSITION;
    float3 wNormal : NORMAL;
    float2 uv      : TEXCOORD0;
    int layer      : TEXCOORD1; // the current layer index that this vertex belongs to
}

VS_Data vert(VS_Data input)
{
    return input;
}

void CreateVertex(inout TriangleStream triStream, float3 pos, float3 normal, float2 uv, int layer)
{
    GS_Data data;

    data.vertex = UnityObjectToClipPos(float4(pos, 1.0));
    data.wNormal = UnityObjectToWorldNormal(normal);
    data.uv = TRANSFORM_TEX(uv, _MainTex);
    data.layer = layer;

    triStream.Append(data);
}

[maxvertexcount(30*3)]
void geom(triangle VS_Data verts[3], inout TriangleStream triStream)
{

    // Calculate the height difference between each layer
    float heightOffset = _FurLength / ((float) _LayerAmount);

    for(uint i = 0; i < (uint)_LayerAmount; ++i)
    {
    // Calculate the new vertex positions by adding the height offset each iteration
        for(uint j = 0; j < 3; ++j)
        {
            verts[j].vertex.xyz = verts[j].vertex.xyz + (verts[j].normal * heightOffset); // add the height offset to the current position
        }

        // Create the vertices
        CreateVertex(triStream, verts[0].vertex, verts[0].normal, verts[0].uv, i+1);
        CreateVertex(triStream, verts[1].vertex, verts[1].normal, verts[1].uv, i+1);
        CreateVertex(triStream, verts[2].vertex, verts[2].normal, verts[2].uv, i+1);

        triStream.RestartStrip();
    }
}

float4 fragment(GS_Data input) : SV_Target
{
    // Diffuse Color
    half4 color = tex2D(_MainTex, input.uv) * _Color;

    // Fur opacity
    float furOpacity = tex2D(_FurOpacityTex, input.uv * _FurDensity).r;
    float furLength = tex2D(_ShellLengthTex, input.uv);

    // Shell opacity
    float opacity = 1 - ((float)input.layer / ((float)_LayerAmount - (float)_LayerOpacity));
    color.a = opacity * furOpacity.r * furLength;

    // Lighting
    float3 NdotL = saturate(dot(input.wNormal, _WorldSpaceLightPos0.xyz)) * _LightColor0.rgb;
    float3 ambient = ShadeSH9(half4(input.wNormal, 1.0));
    NdotL += ambient;
    color.rgb *= NdotL;

    return color;
}
                    </code>
                </pre>
        </section>
    </div>
    </p>

    <p>
    <h3>References</h3>
    <a href="http://developer.download.nvidia.com/SDK/10.5/direct3d/Source/Fur/doc/FurShellsAndFins.pdf"
       target="_blank">
        White Paper - Fur (using Shells and Fins)
    </a>
    </p>


</div>
<!-- /.container -->

<!-- Footer -->
<footer class="py-5 bg-dark">
    <div class="container">
        <p class="m-0 text-center text-white">Copyright &copy; Cédric Van Huffelen 2019</p>
    </div>
    <!-- /.container -->
</footer>

<!-- Bootstrap core JavaScript -->
<script src="vendor/jquery/jquery.min.js"></script>
<script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

</body>

</html>
